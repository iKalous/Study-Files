var     n,i,j,x,k,o,p,ans:longint;
        f:array[0..10010,0..3] of longint;
        dad:array[0..110] of longint;
procedure sort(l,r:longint);
var     i,j,x,y:longint;
begin
        i:=l;
        j:=r;
        x:=f[(l+r) div 2,3];
        repeat
                while f[i,3]<x do inc(i);
                while x<f[j,3] do dec(j);
                if not(i>j) then
                begin
                        y:=f[i,3];
                        f[i,3]:=f[j,3];
                        f[j,3]:=y;
                        y:=f[i,2];
                        f[i,2]:=f[j,2];
                        f[j,2]:=y;
                        y:=f[i,1];
                        f[i,1]:=f[j,1];
                        f[j,1]:=y;
                        inc(i);
                        dec(j);
                end;
        until i>j;
        if l<j then sort(l,j);
        if i<r then sort(i,r);
end;
function find(c:longint):longint;
begin
        if c=dad[c] then exit(c);
        dad[c]:=find(dad[c]);
        exit(dad[c]);
end;
begin
        readln(n);
        for i:=1 to n do
        begin
                for j:=1 to n do
                begin
                        read(x);
                        if x>0 then
                        begin
                                inc(k);
                                f[k,1]:=i;
                                f[k,2]:=j;
                                f[k,3]:=x;
                        end;
                end;
        end;
        sort(1,k);
        for i:=1 to n do dad[i]:=i;
        for i:=1 to k do
        begin
                o:=find(f[i,1]);
                p:=find(f[i,2]);
                if o<>p then
                begin
                        dad[o]:=dad[p];
                        inc(ans,f[i,3]);
                end;
        end;
        writeln(ans);
end.

第一行：	农场的个数，N（3<=N<=100）。
第二行..结尾:	后来的行包含了一个N*N的矩阵,表示每个农场之间的距离。理论上，他们是N行，每行由N个用空格分隔的数组成，实际上，他们限制在80个字符，因此，某些行会紧接着另一些行。当然，对角线将会是0，因为不会有线路从第i个农场到它本身。





#include<cstdio>
long dad[111],f[10000][4],ans,k;
long find(long x)
{
	if (dad[x]==x) return x;
	dad[x]=find(dad[x]);
	return dad[x];
}
void swap(long x,long y,long z)
{
	long t;
	t=f[x][z];
	f[x][z]=f[y][z];
	f[y][z]=t;
}
void build(long x,long y,long z)
{
	f[++k][1]=x;
	f[k][2]=y;
	f[k][3]=z;
}
void qsort(long l,long r)
{
	long i=l,j=r,x=f[(l+r)>>1][3];
	while (i<=j)
	{
		while (f[i][3]<x) i++;
		while (f[j][3]>x) j--;
		if (i<=j)
		{
			swap(i,j,3);
			swap(i,j,1);
			swap(i,j,2);
			i++,j--;
		}
	}
	if (l<j) qsort(l,j);
	if (i<r) qsort(i,r);
}
int main()
{
	long n,m;
	scanf("%ld%ld",&n,&m);
	for (int i=1;i<=m;i++)
	{
		long x,y,z;
		scanf("%ld%ld%ld",&x,&y,&z);
		build(x,y,z);
	}
	qsort(1,k);
	for (int i=1;i<=n;i++) dad[i]=i;
	for (int i=1;i<=k;i++)
	{
		long x,y;
		x=find(f[i][1]);
		y=find(f[i][2]);
		if (x!=y) dad[x]=dad[y],ans+=f[i][3];
	}
	printf("%ld",ans);
}